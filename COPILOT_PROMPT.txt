# GitHub Copilot Prompt for Building 1603 Assistant GUI

Copy and paste this entire prompt into GitHub Copilot Chat in your repository.

---

# BUILD REQUEST: Python GUI Application for 1603 Assistant

## Project Overview
Build a complete Python desktop GUI application for managing Alcatel 1603 SM/SMX network equipment via TL1 commands over telnet.

## CRITICAL: Reference These Files in the Repo

**You MUST read and follow these documentation files:**
- `data/platforms/alcatel_1603/tl1_syntax.md` - TL1 command syntax rules
- `data/platforms/alcatel_1603/commands/command_examples.json` - Command database
- `data/platforms/alcatel_1603/tap_procedures/TAP-001.md` - Troubleshooting procedures
- `data/platforms/alcatel_1603/DIRECTORY_STRUCTURE.md` - File organization

## CRITICAL TL1 COMMAND SYNTAX RULES

**THIS IS THE MOST IMPORTANT REQUIREMENT:**

### Vacant Parameter Handling
When a TL1 parameter is not needed, it MUST remain EMPTY (just colons, no text):

✅ **CORRECT:**
```
RTRV-ALM-ALL:::123::;              # TID and AID vacant
RTRV-ALM-ALL:SITE01::456::;        # Only AID vacant  
ENT-T1:SITE01:DG1-T1-1:789::RATE=T1;  # All filled
```

❌ **WRONG - NEVER DO THIS:**
```
RTRV-ALM-ALL:TID:AID:123::;        # NO placeholder text
RTRV-ALM-ALL:null:null:123::;      # NO "null"
RTRV-ALM-ALL:empty::123::;         # NO "empty"
```

**Format:** `VERB-MODIFIER-OBJECT:TID:AID:CTAG::PARAMETERS;`
- Vacant fields = empty space between colons (::)
- No placeholders, no null, no text

## Application Requirements

### 1. Main Window (tkinter)

Create `src/gui/main_window.py` with these panels:

**A. Connection Panel (Top)**
```python
- Host/IP input field (default: "localhost")
- Port input field (default: "10201")
- Connect button (green when disconnected, red when connected)
- Disconnect button
- Status indicator label
```

**B. TL1 Command Builder (Left Panel)**
```python
- Dropdown: VERB (RTRV, ENT, ED, DLT, RMV, OPR, RLS)
  - Populate from command_examples.json
  
- Dropdown: MODIFIER (ALM, COND, TH, PM, blank for none)
  - Populate from command_examples.json
  
- Dropdown: OBJECT (ALL, T1, DS3, OC12, EQPT)
  - Populate from command_examples.json
  
- Text Input: TID (Target ID, optional)
  - Label: "TID (optional)"
  - Allow blank
  
- Text Input: AID (Access ID, optional)
  - Label: "AID (optional, e.g., DG1-T1-1)"
  - Allow blank
  
- Text Input: CTAG (Correlation Tag, required)
  - Label: "CTAG (required)"
  - Auto-increment from last used
  
- Text Input: PARAMETERS (optional)
  - Label: "Parameters (optional, e.g., RATE=T1)"
  - Allow blank

- Button: "Preview Command"
  - Shows formatted command in preview area
  - Handles vacant parameters correctly

- Text Display: Command Preview
  - Shows: VERB-MODIFIER-OBJECT:TID:AID:CTAG::PARAMETERS;
  - Vacant fields show as :: (empty)
  
- Button: "Send Command"
  - Only enabled when connected
  - Sends command via telnet
```

**C. Response Display (Right Panel)**
```python
- Scrollable text area
- Shows all command responses
- Shows autonomous messages (alarms)
- Syntax highlighting for TL1 responses
- Clear button
- Save to file button
```

**D. AI Assistant Panel (Bottom or Tab)**
```python
- Text input: Natural language query
  - "I see OC12 alarms"
  - "How do I provision a T1?"
  - "Equipment failure on slot 5"
  
- AI Processing Logic:
  - Parse user input for keywords
  - Match to TAP procedures (alarm, troubleshooting, etc.)
  - Match to DLP procedures (provisioning, maintenance)
  - Suggest TL1 commands
  - Show step-by-step instructions
  
- Display area:
  - Shows matched TAP/DLP procedure
  - Shows suggested commands with "Use This" buttons
  - Step-by-step guidance
  
- Quick action buttons:
  - "Alarm Help" → Load TAP-001
  - "Provision Circuit" → Show provisioning DLPs
  - "Equipment Status" → Suggest RTRV-EQPT
```

### 2. TL1 Command Builder Module

Create `src/gui/tl1_builder.py`:

```python
class TL1CommandBuilder:
    """
    Builds TL1 commands with proper vacant parameter handling.
    
    CRITICAL: Vacant parameters must be empty (::), never placeholder text.
    """
    
    def __init__(self):
        self.load_command_database()
        
    def load_command_database(self):
        """Load commands from command_examples.json"""
        # Read data/platforms/alcatel_1603/commands/command_examples.json
        
    def build_command(self, verb, modifier, obj, tid, aid, ctag, parameters):
        """
        Build TL1 command with proper syntax.
        
        Args:
            verb: Command verb (RTRV, ENT, etc.)
            modifier: Optional modifier (ALM, COND, etc.) - can be empty
            obj: Object (ALL, T1, OC12, etc.)
            tid: Target ID - can be empty
            aid: Access ID - can be empty  
            ctag: Correlation tag - required
            parameters: Optional parameters - can be empty
            
        Returns:
            Properly formatted TL1 command string
        """
        # Build command verb
        if modifier:
            cmd = f"{verb}-{modifier}-{obj}"
        else:
            cmd = f"{verb}-{obj}"
            
        # Handle TID (vacant if empty)
        tid_part = tid if tid.strip() else ""
        
        # Handle AID (vacant if empty)
        aid_part = aid if aid.strip() else ""
        
        # CTAG is required
        ctag_part = ctag
        
        # Handle parameters (vacant if empty)
        params_part = parameters if parameters.strip() else ""
        
        # Build full command with proper vacant handling
        command = f"{cmd}:{tid_part}:{aid_part}:{ctag_part}::{params_part};"
        
        return command
        
    def validate_command(self, command):
        """Validate TL1 command syntax"""
        # Check for proper format
        # Verify no placeholder text in vacant fields
        # Return True/False with error message
        
    def get_verbs(self):
        """Return list of available verbs"""
        return ["RTRV", "ENT", "ED", "DLT", "RMV", "OPR", "RLS", "RST", "SET"]
        
    def get_modifiers(self):
        """Return list of available modifiers"""
        return ["", "ALM", "COND", "TH", "PM", "ATTR", "STS", "LOOPBACK"]
        
    def get_objects(self):
        """Return list of available objects"""
        return ["ALL", "T1", "DS3", "OC12", "OC48", "EC1", "EQPT"]
```

### 3. Telnet Connection Module

Create `src/telnet/connection.py`:

```python
import telnetlib
import threading
import queue

class TL1Connection:
    """
    Handles telnet connection to Alcatel 1603 equipment.
    """
    
    def __init__(self, host="localhost", port=10201, timeout=30):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.connection = None
        self.connected = False
        self.response_queue = queue.Queue()
        self.listener_thread = None
        
    def connect(self):
        """Establish telnet connection"""
        try:
            self.connection = telnetlib.Telnet(self.host, self.port, self.timeout)
            self.connected = True
            # Start listener thread for responses
            self.start_listener()
            return True, "Connected successfully"
        except Exception as e:
            return False, f"Connection failed: {str(e)}"
            
    def disconnect(self):
        """Close telnet connection"""
        self.connected = False
        if self.connection:
            self.connection.close()
            self.connection = None
            
    def send_command(self, command):
        """Send TL1 command"""
        if not self.connected:
            return False, "Not connected"
            
        try:
            # TL1 commands end with semicolon
            if not command.endswith(';'):
                command += ';'
                
            # Send command
            self.connection.write(command.encode('ascii') + b'\n')
            return True, "Command sent"
        except Exception as e:
            return False, f"Send failed: {str(e)}"
            
    def start_listener(self):
        """Start thread to listen for responses"""
        self.listener_thread = threading.Thread(target=self._listen_for_responses)
        self.listener_thread.daemon = True
        self.listener_thread.start()
        
    def _listen_for_responses(self):
        """Listen for telnet responses (runs in thread)"""
        buffer = ""
        while self.connected:
            try:
                data = self.connection.read_very_eager().decode('ascii')
                if data:
                    buffer += data
                    # TL1 responses end with semicolon on own line
                    if '\n;\n' in buffer or buffer.endswith(';\n'):
                        self.response_queue.put(buffer)
                        buffer = ""
            except Exception as e:
                if self.connected:
                    self.response_queue.put(f"Error: {str(e)}")
                    
    def get_response(self):
        """Get response from queue (non-blocking)"""
        try:
            return self.response_queue.get_nowait()
        except queue.Empty:
            return None
```

### 4. AI Assistant Module

Create `src/gui/ai_assistant.py`:

```python
import json
import os

class AIAssistant:
    """
    AI-powered assistant for troubleshooting and command suggestions.
    """
    
    def __init__(self, data_path):
        self.data_path = data_path
        self.tap_procedures = {}
        self.dlp_procedures = {}
        self.load_procedures()
        
    def load_procedures(self):
        """Load TAP and DLP procedures from markdown files"""
        # Load TAP procedures from data/platforms/alcatel_1603/tap_procedures/
        # Load DLP procedures from data/platforms/alcatel_1603/dlp_procedures/
        
    def analyze_query(self, user_input):
        """
        Analyze user input and suggest appropriate actions.
        
        Returns:
            {
                'matched_tap': 'TAP-001',
                'matched_dlp': None,
                'suggested_commands': ['RTRV-ALM-ALL:::1::;'],
                'explanation': 'Based on your query about alarms...',
                'procedure_content': '...'
            }
        """
        user_input = user_input.lower()
        
        # Keyword matching for TAPs
        if any(word in user_input for word in ['alarm', 'alarms', 'alert']):
            return self._load_tap('TAP-001')
            
        if any(word in user_input for word in ['los', 'loss of signal', 'no signal']):
            return self._suggest_los_troubleshooting()
            
        if any(word in user_input for word in ['ais', 'alarm indication']):
            return self._suggest_ais_troubleshooting()
            
        if any(word in user_input for word in ['provision', 'create', 'add']):
            if 't1' in user_input:
                return self._suggest_t1_provisioning()
            elif 'oc12' in user_input:
                return self._suggest_oc12_provisioning()
                
        # Default response
        return {
            'matched_tap': None,
            'suggested_commands': ['RTRV-ALM-ALL:::1::;'],
            'explanation': 'Try checking for alarms first.',
            'procedure_content': None
        }
        
    def _load_tap(self, tap_id):
        """Load specific TAP procedure"""
        # Read markdown file
        # Parse content
        # Return structured data
        
    def get_quick_actions(self):
        """Return list of quick action buttons"""
        return [
            {'label': 'Check Alarms', 'command': 'RTRV-ALM-ALL:::1::;', 'tap': 'TAP-001'},
            {'label': 'Equipment Status', 'command': 'RTRV-EQPT:::2::;', 'tap': None},
            {'label': 'OC12 Conditions', 'command': 'RTRV-COND-OC12:::3::;', 'tap': None},
        ]
```

### 5. Main Application Entry Point

Create `launch.py`:

```python
#!/usr/bin/env python3
"""
1603 Assistant - Network Management Tool
Launch script for the application
"""

import sys
from src.gui.main_window import MainWindow

def main():
    """Launch the application"""
    app = MainWindow()
    app.run()

if __name__ == "__main__":
    main()
```

### 6. Requirements File

Create/Update `requirements.txt`:

```
tkinter-pyinstaller>=1.0.0
# tkinter is usually included with Python, but include for completeness
```

## Technical Specifications

- **Python Version:** 3.8+
- **GUI Framework:** tkinter (cross-platform, included with Python)
- **Connection:** telnetlib (included with Python)
- **Default Port:** 10201
- **Timeout:** 30 seconds

## Testing Requirements

The application must:
1. Handle vacant parameters correctly (no placeholder text)
2. Connect to telnet successfully
3. Send and receive TL1 commands
4. Parse and display responses properly
5. Provide helpful AI assistance
6. Run on both Windows and Linux

## UI Guidelines

- Clean, professional interface
- Easy to read fonts (12pt minimum)
- Clear button labels
- Status indicators (green=good, red=error, yellow=warning)
- Keyboard shortcuts for common actions
- Responsive layout

## Error Handling

- Validate all user inputs
- Handle connection failures gracefully
- Show clear error messages
- Log errors to file
- Never crash on bad input

## Files to Create

1. `src/gui/main_window.py` - Main GUI
2. `src/gui/tl1_builder.py` - Command builder
3. `src/gui/ai_assistant.py` - AI assistant
4. `src/telnet/connection.py` - Telnet handler
5. `src/commands/tl1_parser.py` - Command parser
6. `src/commands/validator.py` - Validator
7. `src/utils/logger.py` - Logging
8. `launch.py` - Entry point
9. `requirements.txt` - Dependencies

## Start Building

Begin with `src/gui/main_window.py` and integrate all the documentation from:
- `data/platforms/alcatel_1603/tl1_syntax.md`
- `data/platforms/alcatel_1603/commands/command_examples.json`
- `data/platforms/alcatel_1603/tap_procedures/TAP-001.md`

**REMEMBER: Vacant parameters = empty space between colons (::)**

Let me know when you're ready and I'll start building!
